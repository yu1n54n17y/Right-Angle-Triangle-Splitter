<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Triangle Splitter</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            background: #1e1e2e;
            color: #cdd6f4;
            font-family: 'Inter', sans-serif;
            text-align: center;
            padding: 2em;
            margin: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
        }
        h1 {
            color: #89b4fa;
            font-weight: 700;
            margin-bottom: 0.5em;
        }
        p {
            font-size: 1.1em;
            color: #a6adc8;
        }
        canvas {
            background: #11111b;
            border: 2px solid #585b70;
            border-radius: 8px;
            margin-top: 1em;
            width: 900px;
            height: 900px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.4);
            position: relative;
        }
        input {
            width: 80px;
            margin: 0 8px;
            padding: 8px;
            font-size: 1em;
            background-color: #313244;
            border: 1px solid #585b70;
            color: #cdd6f4;
            border-radius: 6px;
            text-align: center;
            transition: border-color 0.3s, box-shadow 0.3s;
        }
        input:focus {
            outline: none;
            border-color: #89b4fa;
            box-shadow: 0 0 0 2px rgba(137, 180, 250, 0.5);
        }
        .watermark {
            position: absolute;
            bottom: 10px;
            right: 10px;
            font-size: 1em;
            color: rgba(137, 180, 250, 0.4);
            pointer-events: none;
            user-select: none;
            z-index: 100;
        }
        .warning-message {
            color: #fab387;
            font-weight: bold;
            margin-top: 1em;
            height: 1.5em; /* Reserve space to prevent layout shift */
        }
    </style>
</head>
<body>
    <h1>Triangle Side Splitter</h1>
    <p>
        Side a: <input type="number" id="sideA" value="5" oninput="queueTriangleAnimation()">
        Side b: <input type="number" id="sideB" value="5" oninput="queueTriangleAnimation()">
        Side c: <input type="number" id="sideC" value="6" oninput="queueTriangleAnimation()">
    </p>
    <div id="warningMessage" class="warning-message"></div>
    <div style="position: relative; width: 900px; height: 900px;">
        <canvas id="canvas" width="1800" height="1800"></canvas>
        <div class="watermark">Yu-1N_54N_17Y (Yukio77)</div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const renderScale = 2;

        const animationDuration = 500; // milliseconds
        let animationStartTime = null;
        let animationFrameId = null;
        let currentPoints = null;
        let targetPoints = null;

        let hoverSegments = [];
        let hoverSegmentToDraw = null;
        
        const debounceDelay = 100;
        let debounceTimeoutId = null;
        const warningElement = document.getElementById('warningMessage');

        // Easing function for smooth animation
        function easeInOut(t) {
            return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
        }

        // --- Drawing functions ---
        function drawPoint(x, y, label) {
            ctx.beginPath();
            ctx.arc(x, y, 4 * renderScale, 0, 2 * Math.PI);
            ctx.fillStyle = '#f9e2af';
            ctx.fill();
            ctx.fillText(label, x + 6 * renderScale, y - 6 * renderScale);
        }

        function drawLine(p1, p2, color, label = null) {
            if (!p1 || !p2) return;
            ctx.beginPath();
            ctx.moveTo(p1.x, p1.y);
            ctx.lineTo(p2.x, p2.y);
            ctx.strokeStyle = color;
            ctx.lineWidth = 4 * renderScale;
            ctx.stroke();

            if (label !== null) {
                const midX = (p1.x + p2.x) / 2;
                const midY = (p1.y + p2.y) / 2;
                hoverSegments.push({ x1: p1.x, y1: p1.y, x2: p2.x, y2: p2.y, label, x: midX, y: midY });
            }
        }

        function drawHoverLabel(segment) {
            if (!segment) return;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            const textOffset = 20 * renderScale;

            const dx = segment.x2 - segment.x1;
            const dy = segment.y2 - segment.y1;
            const len = Math.sqrt(dx * dx + dy * dy);
            const normalX = -dy / len;
            const normalY = dx / len;

            const labelX = segment.x + normalX * textOffset;
            const labelY = segment.y + normalY * textOffset;

            ctx.font = `bold ${16 * renderScale}px 'Inter', sans-serif`;

            // Draw the background outline for better visibility
            ctx.lineWidth = 6 * renderScale;
            ctx.strokeStyle = '#1e1e2e';
            ctx.strokeText(segment.label, labelX, labelY);

            // Draw the text on top
            ctx.fillStyle = '#f9e2af';
            ctx.fillText(segment.label, labelX, labelY);
        }

        // --- Geometric calculations ---
        function distance(p1, p2) {
            if (!p1 || !p2) return 0;
            return Math.sqrt((p1.x - p2.x) ** 2 + (p1.y - p2.y) ** 2);
        }

        function pointToSegmentDistance(px, py, x1, y1, x2, y2) {
            const A = px - x1;
            const B = py - y1;
            const C = x2 - x1;
            const D = y2 - y1;

            const dot = A * C + B * D;
            const lenSq = C * C + D * D;
            let param = dot / lenSq;

            if (param < 0) param = 0;
            else if (param > 1) param = 1;

            const xx = x1 + param * C;
            const yy = y1 + param * D;
            const dx = px - xx;
            const dy = py - yy;
            return Math.sqrt(dx * dx + dy * dy);
        }

        function getRightTrianglePoints(a, b, c) {
            const epsilon = 1e-5;
            let hypotenuse, leg1, leg2;
            if (Math.abs(a * a + b * b - c * c) < epsilon) {
                [hypotenuse, leg1, leg2] = [c, a, b];
            } else if (Math.abs(b * b + c * c - a * a) < epsilon) {
                [hypotenuse, leg1, leg2] = [a, b, c];
            } else if (Math.abs(c * c + a * a - b * b) < epsilon) {
                [hypotenuse, leg1, leg2] = [b, c, a];
            } else {
                return null;
            }

            const margin = 50 * renderScale;
            const scaleX = (canvas.width - margin * 2) / leg2;
            const scaleY = (canvas.height - margin * 2) / leg1;
            const scale = Math.min(scaleX, scaleY);

            const A = { x: margin, y: canvas.height - margin };
            const B = { x: A.x + leg2 * scale, y: A.y };
            const C = { x: A.x, y: A.y - leg1 * scale };

            return { A, B, C, D: null, scale, isRightTriangle: true, sides: { a, b, c } };
        }

        function getSplitTrianglePoints(a, b, c) {
            const cosAngleA = (b * b + c * c - a * a) / (2 * b * c);
            const angleA = Math.acos(Math.max(-1, Math.min(1, cosAngleA)));
            const sinAngleA = Math.sin(angleA);
            const height = b * sinAngleA;

            if (isNaN(height) || height === 0) return null;

            const margin = 50 * renderScale;
            const scaleX = (canvas.width - margin * 2) / c;
            const scaleY = (canvas.height - margin * 2) / height;
            const scale = Math.min(scaleX, scaleY);

            const A = { x: margin, y: canvas.height - margin };
            const B = { x: A.x + c * scale, y: A.y };
            const C = {
                x: A.x + b * scale * Math.cos(angleA),
                y: A.y - b * scale * sinAngleA
            };

            const D = {
                x: A.x + b * scale * Math.cos(angleA),
                y: A.y
            };

            if (D.x < A.x || D.x > B.x) {
                return null;
            }
            
            return { A, B, C, D, scale, isRightTriangle: false, sides: { a, b, c } };
        }

        // The main rendering function
        function renderTriangle(points, hoverLabel = null) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            hoverSegments = [];
            ctx.font = `${16 * renderScale}px 'Inter', sans-serif`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            if (!points) {
                ctx.fillStyle = '#fab387';
                ctx.fillText('Invalid triangle', canvas.width / 2, canvas.height / 2);
                return;
            }

            const { A, B, C, D, scale, isRightTriangle } = points;
            
            if (isRightTriangle) {
                ctx.fillStyle = '#a6e3a1';
                ctx.fillText('Already a right triangle', 300 * renderScale, 150 * renderScale);
                // Label the sides of the right triangle
                drawLine(A, C, '#cba6f7', (distance(A, C) / scale).toFixed(3));
                drawLine(C, B, '#f5e0dc', (distance(C, B) / scale).toFixed(3));
                drawLine(A, B, '#89b4fa', (distance(A, B) / scale).toFixed(3));
            } else {
                const CD_len = distance(D, C) / scale;
                const AD_len = distance(A, D) / scale;
                const DB_len = distance(D, B) / scale;
                
                // Draw all lines of the smaller triangles and label them
                drawLine(A, C, '#cba6f7', (distance(A, C) / scale).toFixed(3));
                drawLine(C, B, '#f5e0dc', (distance(C, B) / scale).toFixed(3));
                drawLine(C, D, '#a6e3a1', CD_len.toFixed(3));
                
                // Only label the split segments if point D is on the base
                if (D.x >= A.x && D.x <= B.x) {
                    drawLine(A, D, '#89b4fa', AD_len.toFixed(3));
                    drawLine(D, B, '#fab387', DB_len.toFixed(3));
                } else {
                    drawLine(A, B, '#89b4fa', (distance(A, B) / scale).toFixed(3));
                }
            }

            // Draw points after lines to make them visible
            drawPoint(A.x, A.y, 'A');
            drawPoint(B.x, B.y, 'B');
            drawPoint(C.x, C.y, 'C');
            if (D) {
                drawPoint(D.x, D.y, 'D');
            }

            // Draw hover label if provided
            if (hoverLabel) {
                drawHoverLabel(hoverLabel);
            }
        }

        // --- Animation functions ---
        function queueTriangleAnimation() {
            clearTimeout(debounceTimeoutId);
            debounceTimeoutId = setTimeout(() => {
                const a = parseFloat(document.getElementById('sideA').value);
                const b = parseFloat(document.getElementById('sideB').value);
                const c = parseFloat(document.getElementById('sideC').value);

                // Combined validation logic
                const isInvalid = isNaN(a) || isNaN(b) || isNaN(c) || a <= 0 || b <= 0 || c <= 0;
                const isTooSmall = a < 0.2 || b < 0.2 || c < 0.2;
                
                if (isInvalid) {
                    warningElement.textContent = "";
                    if (animationFrameId) {
                        cancelAnimationFrame(animationFrameId);
                        animationFrameId = null;
                    }
                    currentPoints = null;
                    renderTriangle(null);
                    return;
                }
                
                if (isTooSmall) {
                    warningElement.textContent = "One or more of the sides is smaller than 0.2. The triangle is not possible to make in Gearworks.";
                } else {
                    warningElement.textContent = "";
                }

                let newTargetPoints = getRightTrianglePoints(a, b, c);
                if (!newTargetPoints) {
                    newTargetPoints = getSplitTrianglePoints(a, b, c) || getSplitTrianglePoints(b, c, a) || getSplitTrianglePoints(c, a, b);
                }

                if (!newTargetPoints) {
                    if (animationFrameId) {
                        cancelAnimationFrame(animationFrameId);
                        animationFrameId = null;
                    }
                    currentPoints = null;
                    renderTriangle(null);
                    return;
                }
                
                // If animation is already running, set currentPoints to the current interpolated state
                if (animationFrameId && currentPoints && targetPoints) {
                    const elapsedTime = performance.now() - animationStartTime;
                    const progress = Math.min(elapsedTime / animationDuration, 1);
                    const easedProgress = easeInOut(progress);

                    const interpolatedA = {
                        x: currentPoints.A.x + (targetPoints.A.x - currentPoints.A.x) * easedProgress,
                        y: currentPoints.A.y + (targetPoints.A.y - currentPoints.A.y) * easedProgress
                    };
                    const interpolatedB = {
                        x: currentPoints.B.x + (targetPoints.B.x - currentPoints.B.x) * easedProgress,
                        y: currentPoints.B.y + (targetPoints.B.y - currentPoints.B.y) * easedProgress
                    };
                    const interpolatedC = {
                        x: currentPoints.C.x + (targetPoints.C.x - currentPoints.C.x) * easedProgress,
                        y: currentPoints.C.y + (targetPoints.C.y - currentPoints.C.y) * easedProgress
                    };
                    const interpolatedD = (currentPoints.D && targetPoints.D) ? {
                        x: currentPoints.D.x + (targetPoints.D.x - currentPoints.D.x) * easedProgress,
                        y: currentPoints.D.y + (targetPoints.D.y - currentPoints.D.y) * easedProgress
                    } : null;

                    currentPoints = {
                        A: interpolatedA, B: interpolatedB, C: interpolatedC, D: interpolatedD,
                        scale: currentPoints.scale + (targetPoints.scale - currentPoints.scale) * easedProgress,
                        isRightTriangle: currentPoints.isRightTriangle,
                        sides: currentPoints.sides
                    };
                }

                if (animationFrameId) {
                    cancelAnimationFrame(animationFrameId);
                }

                // If this is the first run, or if the triangle type changed, re-initialize
                if (!currentPoints || currentPoints.isRightTriangle !== newTargetPoints.isRightTriangle) {
                    currentPoints = newTargetPoints;
                    renderTriangle(currentPoints);
                } else {
                    targetPoints = newTargetPoints;
                    animationStartTime = null;
                    animationFrameId = requestAnimationFrame(animateTriangle);
                }

            }, debounceDelay);
        }

        function animateTriangle(currentTime) {
            if (animationStartTime === null) {
                animationStartTime = currentTime;
            }

            const elapsedTime = currentTime - animationStartTime;
            const progress = Math.min(elapsedTime / animationDuration, 1);
            const easedProgress = easeInOut(progress);
            
            const interpolatedPoints = {
                A: {
                    x: currentPoints.A.x + (targetPoints.A.x - currentPoints.A.x) * easedProgress,
                    y: currentPoints.A.y + (targetPoints.A.y - currentPoints.A.y) * easedProgress
                },
                B: {
                    x: currentPoints.B.x + (targetPoints.B.x - currentPoints.B.x) * easedProgress,
                    y: currentPoints.B.y + (targetPoints.B.y - currentPoints.B.y) * easedProgress
                },
                C: {
                    x: currentPoints.C.x + (targetPoints.C.x - currentPoints.C.x) * easedProgress,
                    y: currentPoints.C.y + (targetPoints.C.y - currentPoints.C.y) * easedProgress
                },
                D: null,
                scale: currentPoints.scale + (targetPoints.scale - currentPoints.scale) * easedProgress,
                isRightTriangle: targetPoints.isRightTriangle,
                sides: targetPoints.sides
            };

            // Interpolate point D only if it exists in both current and target states
            if (currentPoints.D && targetPoints.D) {
                interpolatedPoints.D = {
                    x: currentPoints.D.x + (targetPoints.D.x - currentPoints.D.x) * easedProgress,
                    y: currentPoints.D.y + (targetPoints.D.y - currentPoints.D.y) * easedProgress
                };
            } else if (targetPoints.D) {
                interpolatedPoints.D = targetPoints.D;
            } else if (currentPoints.D) {
                interpolatedPoints.D = currentPoints.D;
            }

            renderTriangle(interpolatedPoints, hoverSegmentToDraw);

            if (progress < 1) {
                animationFrameId = requestAnimationFrame(animateTriangle);
            } else {
                animationFrameId = null;
                currentPoints = targetPoints;
                renderTriangle(currentPoints, hoverSegmentToDraw);
            }
        }

        // --- Event listeners ---
        canvas.addEventListener('mousemove', (e) => {
            if (!currentPoints) return;

            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            const canvasX = x * renderScale;
            const canvasY = y * renderScale;
            
            let foundHover = null;
            for (const seg of hoverSegments) {
                const dist = pointToSegmentDistance(canvasX, canvasY, seg.x1, seg.y1, seg.x2, seg.y2);
                if (dist < 10 * renderScale) {
                    foundHover = seg;
                    break;
                }
            }

            if (foundHover !== hoverSegmentToDraw) {
                hoverSegmentToDraw = foundHover;
                if (!animationFrameId) {
                    renderTriangle(currentPoints, hoverSegmentToDraw);
                }
            }
        });

        // Initialize on load
        queueTriangleAnimation();
    </script>
</body>
</html>
