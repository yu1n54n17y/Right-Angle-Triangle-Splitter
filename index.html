<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Triangle Splitter</title>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            background: #1e1e2e;
            color: #cdd6f4;
            font-family: 'Roboto', sans-serif;
            text-align: center;
            padding: 2em;
            margin: 0;
            min-height: 100vh;
        }
        h1 {
            color: #89b4fa;
            font-weight: 700;
            margin-bottom: 0.5em;
        }
        h3 {
            color: #b4befe;
            font-weight: 400;
            margin-top: 0;
        }
        p {
            font-size: 1.1em;
            color: #a6adc8;
        }
        .container {
            display: flex;
            justify-content: center;
            align-items: flex-start;
            gap: 2em;
            flex-wrap: wrap;
        }
        canvas {
            background: #11111b;
            border: 2px solid #585b70;
            border-radius: 8px;
            width: 900px;
            height: 900px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.4);
            position: relative;
        }
        .results-panel {
            background: #11111b;
            border: 2px solid #585b70;
            border-radius: 8px;
            padding: 1.5em;
            width: 300px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.4);
            text-align: left;
            display: flex;
            flex-direction: column;
        }
        .results-panel h2 {
            color: #f38ba8;
            margin-top: 0;
            font-weight: 700;
        }
        .results-panel table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 1em;
        }
        .results-panel th, .results-panel td {
            padding: 0.5em 0;
            border-bottom: 1px solid #585b70;
            color: #cdd6f4;
        }
        .results-panel th {
            text-align: left;
            color: #bac2de;
            font-weight: 700;
        }
        .results-panel td {
            text-align: right;
            font-family: 'Courier New', Courier, monospace;
        }
        input {
            width: 80px;
            margin: 0 8px;
            padding: 8px;
            font-size: 1em;
            background-color: #313244;
            border: 1px solid #585b70;
            color: #cdd6f4;
            border-radius: 6px;
            text-align: center;
            transition: border-color 0.3s, box-shadow 0.3s;
        }
        input:focus {
            outline: none;
            border-color: #89b4fa;
            box-shadow: 0 0 0 2px rgba(137, 180, 250, 0.5);
        }
        .watermark {
            position: absolute;
            bottom: 10px;
            right: 10px;
            font-size: 1em;
            color: rgba(137, 180, 250, 0.4);
            pointer-events: none;
            user-select: none;
            z-index: 100;
        }
        .warning-message {
            color: #fab387;
            font-weight: bold;
            margin-top: 1em;
            height: 1.5em; /* Reserve space to prevent layout shift */
        }
    </style>
</head>
<body>
    <h1>R.A.T.S.</h1>
    <h3>Right Angle Triangle Splitter</h3>
    <p>
        Side a: <input type="number" id="sideA" value="5" oninput="queueTriangleAnimation()">
        Side b: <input type="number" id="sideB" value="5" oninput="queueTriangleAnimation()">
        Side c: <input type="number" id="sideC" value="6" oninput="queueTriangleAnimation()">
    </p>
    <div id="warningMessage" class="warning-message"></div>
    <div class="container">
        <div style="position: relative;">
            <canvas id="canvas" width="1800" height="1800"></canvas>
            <div class="watermark">Yu-1N_54N_17Y (Yukio77)</div>
        </div>
        <div id="resultsPanel" class="results-panel">
            <h2>Calculated Values</h2>
            <div id="valuesTable"></div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const renderScale = 2;

        const animationDuration = 500; // milliseconds
        let animationStartTime = null;
        let animationFrameId = null;
        let currentPoints = null;
        let targetPoints = null;

        let hoverSegments = [];
        let hoverSegmentToDraw = null;
        
        const debounceDelay = 100;
        let debounceTimeoutId = null;
        const warningElement = document.getElementById('warningMessage');
        const valuesTableElement = document.getElementById('valuesTable');

        // Helper function to format a number, removing redundant trailing zeros
        function formatNumber(num) {
            return parseFloat(num.toFixed(3));
        }

        // Easing function for smooth animation
        function easeInOut(t) {
            return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
        }

        // --- Drawing functions ---
        function drawLine(p1, p2, color, label = null) {
            if (!p1 || !p2) return;
            ctx.beginPath();
            ctx.moveTo(p1.x, p1.y);
            ctx.lineTo(p2.x, p2.y);
            ctx.strokeStyle = color;
            ctx.lineWidth = 4 * renderScale;
            ctx.stroke();

            if (label !== null) {
                const midX = (p1.x + p2.x) / 2;
                const midY = (p1.y + p2.y) / 2;
                hoverSegments.push({ x1: p1.x, y1: p1.y, x2: p2.x, y2: p2.y, label, x: midX, y: midY });
            }
        }

        function drawHoverLabel(segment) {
            if (!segment) return;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            const textOffset = 20 * renderScale;

            const dx = segment.x2 - segment.x1;
            const dy = segment.y2 - segment.y1;
            const len = Math.sqrt(dx * dx + dy * dy);
            const normalX = -dy / len;
            const normalY = dx / len;

            const labelX = segment.x + normalX * textOffset;
            const labelY = segment.y + normalY * textOffset;

            ctx.font = `bold ${16 * renderScale}px 'Roboto', sans-serif`;

            // Draw the background outline for better visibility
            ctx.lineWidth = 10 * renderScale; // Increased outline for visibility
            ctx.strokeStyle = '#1e1e2e';
            ctx.strokeText(segment.label, labelX, labelY);

            // Draw the text on top
            ctx.fillStyle = '#f9e2af';
            ctx.fillText(segment.label, labelX, labelY);
        }

        // --- Geometric calculations ---
        function distance(p1, p2) {
            if (!p1 || !p2) return 0;
            return Math.sqrt((p1.x - p2.x) ** 2 + (p1.y - p2.y) ** 2);
        }

        function pointToSegmentDistance(px, py, x1, y1, x2, y2) {
            const A = px - x1;
            const B = py - y1;
            const C = x2 - x1;
            const D = y2 - y1;

            const dot = A * C + B * D;
            const lenSq = C * C + D * D;
            let param = dot / lenSq;

            if (param < 0) param = 0;
            else if (param > 1) param = 1;

            const xx = x1 + param * C;
            const yy = y1 + param * D;
            const dx = px - xx;
            const dy = py - yy;
            return Math.sqrt(dx * dx + dy * dy);
        }

        function getRightTrianglePoints(a, b, c) {
            const epsilon = 1e-5;
            let hypotenuse, leg1, leg2;
            if (Math.abs(a * a + b * b - c * c) < epsilon) {
                [hypotenuse, leg1, leg2] = [c, a, b];
            } else if (Math.abs(b * b + c * c - a * a) < epsilon) {
                [hypotenuse, leg1, leg2] = [a, b, c];
            } else if (Math.abs(c * c + a * a - b * b) < epsilon) {
                [hypotenuse, leg1, leg2] = [b, c, a];
            } else {
                return null;
            }

            const margin = 50 * renderScale;
            const scaleX = (canvas.width - margin * 2) / leg2;
            const scaleY = (canvas.height - margin * 2) / leg1;
            const scale = Math.min(scaleX, scaleY);

            // Standard orientation: base at the bottom, right angle at the bottom left
            const A = { x: margin, y: canvas.height - margin };
            const B = { x: A.x + leg2 * scale, y: A.y };
            const C = { x: A.x, y: A.y - leg1 * scale };

            return { A, B, C, D: null, scale, isRightTriangle: true, sides: { a, b, c } };
        }

        function getSplitTrianglePoints(a, b, c) {
            // Here c is the base, a and b are the other two sides.
            // Using the Law of Cosines to find the angle A to calculate the altitude and base segments.
            const cosAngleA = (b * b + c * c - a * a) / (2 * b * c);
            const angleA = Math.acos(Math.max(-1, Math.min(1, cosAngleA)));
            const sinAngleA = Math.sin(angleA);
            const height = b * sinAngleA;

            if (isNaN(height) || height === 0) {
                return null;
            }

            const margin = 50 * renderScale;
            const scaleX = (canvas.width - margin * 2) / c;
            const scaleY = (canvas.height - margin * 2) / height;
            const scale = Math.min(scaleX, scaleY);

            // Standard orientation: base at the bottom
            const A = { x: margin, y: canvas.height - margin };
            const B = { x: A.x + c * scale, y: A.y };
            const C = {
                x: A.x + b * scale * Math.cos(angleA),
                y: A.y - b * scale * sinAngleA
            };

            const D = {
                x: A.x + b * scale * Math.cos(angleA),
                y: A.y
            };

            const altitude = height;
            const baseSegment1 = b * Math.cos(angleA);
            const baseSegment2 = c - baseSegment1;

            if (D.x < A.x || D.x > B.x) {
                return null;
            }
            
            return {
                A, B, C, D, scale, isRightTriangle: false, sides: { a, b, c },
                calculatedLengths: {
                    altitude,
                    baseSegment1,
                    baseSegment2
                }
            };
        }

        function findBestSplitTrianglePoints(a, b, c) {
            const splits = [];

            // Try splitting with side a as the base
            const splitA = getSplitTrianglePoints(b, c, a);
            if (splitA) {
                const score = Math.abs(splitA.calculatedLengths.baseSegment1 - splitA.calculatedLengths.baseSegment2);
                splits.push({ points: splitA, score });
            }

            // Try splitting with side b as the base
            const splitB = getSplitTrianglePoints(a, c, b);
            if (splitB) {
                const score = Math.abs(splitB.calculatedLengths.baseSegment1 - splitB.calculatedLengths.baseSegment2);
                splits.push({ points: splitB, score });
            }

            // Try splitting with side c as the base
            const splitC = getSplitTrianglePoints(a, b, c);
            if (splitC) {
                const score = Math.abs(splitC.calculatedLengths.baseSegment1 - splitC.calculatedLengths.baseSegment2);
                splits.push({ points: splitC, score });
            }

            if (splits.length === 0) {
                return null;
            }

            // Find the split with the lowest score (most symmetrical)
            let bestSplit = splits[0];
            for (let i = 1; i < splits.length; i++) {
                if (splits[i].score < bestSplit.score) {
                    bestSplit = splits[i];
                }
            }
            return bestSplit.points;
        }

        // The main rendering function
        function renderTriangle(points, hoverLabel = null) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            hoverSegments = [];
            ctx.font = `${16 * renderScale}px 'Roboto', sans-serif`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            updateResultsPanel(points);

            if (!points) {
                ctx.fillStyle = '#fab387';
                ctx.fillText('Invalid triangle', canvas.width / 2, canvas.height / 2);
                return;
            }

            const { A, B, C, D, scale, isRightTriangle } = points;
            
            if (isRightTriangle) {
                ctx.fillStyle = '#a6e3a1';
                ctx.fillText('Already a right triangle', 300 * renderScale, 150 * renderScale);
                // Label the sides of the right triangle
                drawLine(A, C, '#cba6f7', formatNumber(distance(A, C) / scale));
                drawLine(C, B, '#f5e0dc', formatNumber(distance(C, B) / scale));
                drawLine(A, B, '#89b4fa', formatNumber(distance(A, B) / scale));
            } else {
                const { altitude, baseSegment1, baseSegment2 } = points.calculatedLengths;

                // Draw all lines of the smaller triangles and label them
                drawLine(A, C, '#cba6f7', formatNumber(distance(A, C) / scale));
                drawLine(C, B, '#f5e0dc', formatNumber(distance(C, B) / scale));
                drawLine(C, D, '#a6e3a1', formatNumber(altitude));
                
                // Only label the split segments if point D is on the base
                if (D.x >= A.x && D.x <= B.x) {
                    drawLine(A, D, '#89b4fa', formatNumber(baseSegment1));
                    drawLine(D, B, '#fab387', formatNumber(baseSegment2));
                } else {
                    drawLine(A, B, '#89b4fa', formatNumber(distance(A, B) / scale));
                }
            }
            // Draw hover label if provided
            if (hoverLabel) {
                drawHoverLabel(hoverLabel);
            }
        }
        
        // --- Update Results Panel ---
        function updateResultsPanel(points) {
            if (!points) {
                valuesTableElement.innerHTML = '';
                return;
            }

            const { scale, isRightTriangle, sides } = points;
            let tableHTML = '<table><tbody>';

            // Update values table
            if (isRightTriangle) {
                tableHTML += `<tr><th>Side a</th><td>${formatNumber(sides.a)}</td></tr>`;
                tableHTML += `<tr><th>Side b</th><td>${formatNumber(sides.b)}</td></tr>`;
                tableHTML += `<tr><th>Side c</th><td>${formatNumber(sides.c)}</td></tr>`;
            } else {
                const { altitude, baseSegment1, baseSegment2 } = points.calculatedLengths;
                
                // We use the original sides for the display as they're the inputs
                const [sideA, sideB, sideC] = Object.values(sides);
                
                tableHTML += `<tr><th>Left Base 1</th><td>${formatNumber(baseSegment1)}</td></tr>`;
                tableHTML += `<tr><th>Common Side</th><td>${formatNumber(altitude)}</td></tr>`;
                tableHTML += `<tr><th>Right Base 2</th><td>${formatNumber(baseSegment2)}</td></tr>`;
            }
            
            tableHTML += '</tbody></table>';
            valuesTableElement.innerHTML = tableHTML;
        }

        // --- Animation functions ---
        function queueTriangleAnimation() {
            clearTimeout(debounceTimeoutId);
            debounceTimeoutId = setTimeout(() => {
                const a = parseFloat(document.getElementById('sideA').value);
                const b = parseFloat(document.getElementById('sideB').value);
                const c = parseFloat(document.getElementById('sideC').value);

                // Combined validation logic
                const isInvalid = isNaN(a) || isNaN(b) || isNaN(c) || a <= 0 || b <= 0 || c <= 0;
                let isTooSmall = a < 0.2 || b < 0.2 || c < 0.2;
                
                if (isInvalid) {
                    warningElement.textContent = "";
                    if (animationFrameId) {
                        cancelAnimationFrame(animationFrameId);
                        animationFrameId = null;
                    }
                    currentPoints = null;
                    renderTriangle(null);
                    return;
                }

                let newTargetPoints = getRightTrianglePoints(a, b, c);
                if (!newTargetPoints) {
                    newTargetPoints = findBestSplitTrianglePoints(a, b, c);
                    if (newTargetPoints && newTargetPoints.calculatedLengths) {
                        const { altitude, baseSegment1, baseSegment2 } = newTargetPoints.calculatedLengths;
                        if (altitude < 0.2 || baseSegment1 < 0.2 || baseSegment2 < 0.2) {
                            isTooSmall = true;
                        }
                    }
                }
                
                if (isTooSmall) {
                    warningElement.textContent = "One or more of the sides or calculated segments is smaller than 0.2. The triangle is not possible to make in Gearworks.";
                } else {
                    warningElement.textContent = "";
                }

                if (!newTargetPoints) {
                    if (animationFrameId) {
                        cancelAnimationFrame(animationFrameId);
                        animationFrameId = null;
                    }
                    currentPoints = null;
                    renderTriangle(null);
                    return;
                }
                
                // If animation is already running, set currentPoints to the current interpolated state
                if (animationFrameId && currentPoints && targetPoints) {
                    const elapsedTime = performance.now() - animationStartTime;
                    const progress = Math.min(elapsedTime / animationDuration, 1);
                    const easedProgress = easeInOut(progress);

                    const interpolatedA = {
                        x: currentPoints.A.x + (targetPoints.A.x - currentPoints.A.x) * easedProgress,
                        y: currentPoints.A.y + (targetPoints.A.y - currentPoints.A.y) * easedProgress
                    };
                    const interpolatedB = {
                        x: currentPoints.B.x + (targetPoints.B.x - currentPoints.B.x) * easedProgress,
                        y: currentPoints.B.y + (targetPoints.B.y - currentPoints.B.y) * easedProgress
                    };
                    const interpolatedC = {
                        x: currentPoints.C.x + (targetPoints.C.x - currentPoints.C.x) * easedProgress,
                        y: currentPoints.C.y + (targetPoints.C.y - currentPoints.C.y) * easedProgress
                    };
                    const interpolatedD = (currentPoints.D && targetPoints.D) ? {
                        x: currentPoints.D.x + (targetPoints.D.x - currentPoints.D.x) * easedProgress,
                        y: currentPoints.D.y + (targetPoints.D.y - currentPoints.D.y) * easedProgress
                    } : null;

                    currentPoints = {
                        A: interpolatedA, B: interpolatedB, C: interpolatedC, D: interpolatedD,
                        scale: currentPoints.scale + (targetPoints.scale - currentPoints.scale) * easedProgress,
                        isRightTriangle: currentPoints.isRightTriangle,
                        sides: currentPoints.sides,
                        calculatedLengths: currentPoints.calculatedLengths
                    };
                }

                if (animationFrameId) {
                    cancelAnimationFrame(animationFrameId);
                }

                // If this is the first run, or if the triangle type changed, re-initialize
                if (!currentPoints || currentPoints.isRightTriangle !== newTargetPoints.isRightTriangle) {
                    currentPoints = newTargetPoints;
                    renderTriangle(currentPoints);
                } else {
                    targetPoints = newTargetPoints;
                    animationStartTime = null;
                    animationFrameId = requestAnimationFrame(animateTriangle);
                }

            }, debounceDelay);
        }

        function animateTriangle(currentTime) {
            if (animationStartTime === null) {
                animationStartTime = currentTime;
            }

            const elapsedTime = currentTime - animationStartTime;
            const progress = Math.min(elapsedTime / animationDuration, 1);
            const easedProgress = easeInOut(progress);
            
            const interpolatedPoints = {
                A: {
                    x: currentPoints.A.x + (targetPoints.A.x - currentPoints.A.x) * easedProgress,
                    y: currentPoints.A.y + (targetPoints.A.y - currentPoints.A.y) * easedProgress
                },
                B: {
                    x: currentPoints.B.x + (targetPoints.B.x - currentPoints.B.x) * easedProgress,
                    y: currentPoints.B.y + (targetPoints.B.y - currentPoints.B.y) * easedProgress
                },
                C: {
                    x: currentPoints.C.x + (targetPoints.C.x - currentPoints.C.x) * easedProgress,
                    y: currentPoints.C.y + (targetPoints.C.y - currentPoints.C.y) * easedProgress
                },
                D: null,
                scale: currentPoints.scale + (targetPoints.scale - currentPoints.scale) * easedProgress,
                isRightTriangle: targetPoints.isRightTriangle,
                sides: targetPoints.sides
            };

            // Interpolate point D only if it exists in both current and target states
            if (currentPoints.D && targetPoints.D) {
                interpolatedPoints.D = {
                    x: currentPoints.D.x + (targetPoints.D.x - currentPoints.D.x) * easedProgress,
                    y: currentPoints.D.y + (targetPoints.D.y - currentPoints.D.y) * easedProgress
                };
            } else if (targetPoints.D) {
                interpolatedPoints.D = targetPoints.D;
            } else if (currentPoints.D) {
                interpolatedPoints.D = currentPoints.D;
            }
            
            interpolatedPoints.calculatedLengths = targetPoints.calculatedLengths;

            renderTriangle(interpolatedPoints, hoverSegmentToDraw);

            if (progress < 1) {
                animationFrameId = requestAnimationFrame(animateTriangle);
            } else {
                animationFrameId = null;
                currentPoints = interpolatedPoints;
                renderTriangle(currentPoints, hoverSegmentToDraw);
            }
        }

        // --- Event listeners ---
        canvas.addEventListener('mousemove', (e) => {
            if (!currentPoints) return;

            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            const canvasX = x * renderScale;
            const canvasY = y * renderScale;
            
            let foundHover = null;
            for (const seg of hoverSegments) {
                const dist = pointToSegmentDistance(canvasX, canvasY, seg.x1, seg.y1, seg.x2, seg.y2);
                if (dist < 10 * renderScale) {
                    foundHover = seg;
                    break;
                }
            }

            if (foundHover !== hoverSegmentToDraw) {
                hoverSegmentToDraw = foundHover;
                if (!animationFrameId) {
                    renderTriangle(currentPoints, hoverSegmentToDraw);
                }
            }
        });

        // Initialize on load
        queueTriangleAnimation();
    </script>
</body>
</html>
